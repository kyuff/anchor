// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package env_test

import (
	"sync"
)

// TestingTMock is a mock implementation of env.TestingT.
//
//	func TestSomethingThatUsesTestingT(t *testing.T) {
//
//		// make and configure a mocked env.TestingT
//		mockedTestingT := &TestingTMock{
//			SetenvFunc: func(key string, val string)  {
//				panic("mock out the Setenv method")
//			},
//		}
//
//		// use mockedTestingT in code that requires env.TestingT
//		// and then make assertions.
//
//	}
type TestingTMock struct {
	// SetenvFunc mocks the Setenv method.
	SetenvFunc func(key string, val string)

	// calls tracks calls to the methods.
	calls struct {
		// Setenv holds details about calls to the Setenv method.
		Setenv []struct {
			// Key is the key argument value.
			Key string
			// Val is the val argument value.
			Val string
		}
	}
	lockSetenv sync.RWMutex
}

// Setenv calls SetenvFunc.
func (mock *TestingTMock) Setenv(key string, val string) {
	if mock.SetenvFunc == nil {
		panic("TestingTMock.SetenvFunc: method is nil but TestingT.Setenv was just called")
	}
	callInfo := struct {
		Key string
		Val string
	}{
		Key: key,
		Val: val,
	}
	mock.lockSetenv.Lock()
	mock.calls.Setenv = append(mock.calls.Setenv, callInfo)
	mock.lockSetenv.Unlock()
	mock.SetenvFunc(key, val)
}

// SetenvCalls gets all the calls that were made to Setenv.
// Check the length with:
//
//	len(mockedTestingT.SetenvCalls())
func (mock *TestingTMock) SetenvCalls() []struct {
	Key string
	Val string
} {
	var calls []struct {
		Key string
		Val string
	}
	mock.lockSetenv.RLock()
	calls = mock.calls.Setenv
	mock.lockSetenv.RUnlock()
	return calls
}
